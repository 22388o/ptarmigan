////////////////////////////////////////////////////////////////////////
//FAKE関数

//FAKE_VALUE_FUNC(int, external_function, int);

////////////////////////////////////////////////////////////////////////

class keys_native: public testing::Test {
protected:
    virtual void SetUp() {
        //RESET_FAKE(external_function)
        ucoin_init(UCOIN_TESTNET, true);
    }

    virtual void TearDown() {
        ASSERT_EQ(0, ucoin_dbg_malloc_cnt());
        ucoin_term();
    }

public:
    static void DumpBin(const uint8_t *pData, uint16_t Len)
    {
        for (uint16_t lp = 0; lp < Len; lp++) {
            printf("%02x", pData[lp]);
        }
        printf("\n");
    }
};

////////////////////////////////////////////////////////////////////////

TEST_F(keys_native, pub2p2wpkh_long)
{
    bool ret;
    char waddr[UCOIN_SZ_WPKHADDR];

    ucoin_term();
    ucoin_init(UCOIN_MAINNET, true);

    //https://github.com/bitcoin/bips/blob/master/bip-0142.mediawiki#example
    //なんで非圧縮の公開鍵を使ってるんだよ！
    const uint8_t PUB1_LONG[] = {
        0x04, 0x50, 0x86, 0x3A, 0xD6, 0x4A, 0x87, 0xAE, 0x8A,
        0x2F, 0xE8, 0x3C, 0x1A, 0xF1, 0xA8, 0x40, 0x3C,
        0xB5, 0x3F, 0x53, 0xE4, 0x86, 0xD8, 0x51, 0x1D,
        0xAD, 0x8A, 0x04, 0x88, 0x7E, 0x5B, 0x23, 0x52,
        0x2C, 0xD4, 0x70, 0x24, 0x34, 0x53, 0xA2, 0x99,
        0xFA, 0x9E, 0x77, 0x23, 0x77, 0x16, 0x10, 0x3A,
        0xBC, 0x11, 0xA1, 0xDF, 0x38, 0x85, 0x5E, 0xD6,
        0xF2, 0xEE, 0x18, 0x7E, 0x9C, 0x58, 0x2B, 0xA6,
    };
    const char WADDR[] = "p2xtZoXeX5X8BP8JfFhQK2nD3emtjch7UeFm";
    ret = ucoin_keys_pub2p2wpkh(waddr, PUB1_LONG);
    ASSERT_TRUE(ret);
    ASSERT_STREQ(WADDR, waddr);
}


TEST_F(keys_native, pub2p2wpkh_short)
{
    bool ret;
    char waddr[UCOIN_SZ_WPKHADDR];
    const uint8_t PUB[] = {
        0x03, 0xbe, 0xce, 0xc4, 0x1f, 0x68, 0xd7, 0x7f,
        0xde, 0x9e, 0x97, 0x2c, 0x79, 0xaa, 0x0e, 0x6e,
        0x4e, 0x81, 0x8b, 0xd3, 0x04, 0x62, 0x76, 0x96,
        0x9e, 0x79, 0x37, 0x4e, 0xc0, 0x56, 0x1b, 0xa4,
        0x59,
    };

    ret = ucoin_keys_pub2p2wpkh(waddr, PUB);
    ASSERT_TRUE(ret);
    //他のツールで生成できないので、基本的なチェックだけ行う
    ASSERT_EQ('Q', waddr[0]);
    ASSERT_EQ('W', waddr[1]);
    ASSERT_EQ(UCOIN_SZ_WPKHADDR - 1, strlen(waddr));    //サイズは固定
}


TEST_F(keys_native, addr2p2wpkh)
{
    bool ret;
    const char ADDR[] = "mtLLAiafrhzcjSZqp2Ts86Gv7PupWnXKUc";
    char waddr[UCOIN_SZ_WPKHADDR];

    ret = ucoin_keys_addr2p2wpkh(waddr, ADDR);
    ASSERT_TRUE(ret);
    //他のツールで生成できないので、基本的なチェックだけ行う
    ASSERT_EQ('Q', waddr[0]);
    ASSERT_EQ('W', waddr[1]);
    ASSERT_EQ(UCOIN_SZ_WPKHADDR - 1, strlen(waddr));    //サイズは固定

    //QWzAZ3ApbA6PDFVn6A2ZuYXNkmkkys5iYe2o
}


TEST_F(keys_native, wit2p2wsh)
{
    const uint8_t REDEEM[] = {
        0x52, 0x21, 0x03, 0xd7, 0x98, 0x23, 0x4d, 0xf0,
        0x07, 0xfe, 0x4d, 0x6f, 0x9c, 0x08, 0xeb, 0x5a,
        0x81, 0xc7, 0xca, 0xe1, 0x06, 0x38, 0xa0, 0xe6,
        0xc8, 0x40, 0xad, 0x80, 0xfd, 0x56, 0xf1, 0x32,
        0xa2, 0x4c, 0xaf, 0x21, 0x02, 0x1c, 0x5f, 0x25,
        0x61, 0x40, 0x24, 0x56, 0xcc, 0x46, 0x8f, 0xac,
        0x15, 0xe2, 0x15, 0x2d, 0xf0, 0x32, 0x2b, 0x74,
        0xef, 0xe9, 0x33, 0xce, 0x21, 0x2b, 0x08, 0x42,
        0xb4, 0x76, 0x77, 0x5d, 0x22, 0x21, 0x03, 0x06,
        0x84, 0xb3, 0x3c, 0xde, 0x5a, 0xd6, 0x80, 0x69,
        0x76, 0x22, 0x1a, 0x8e, 0xac, 0x18, 0x33, 0xf6,
        0x43, 0x23, 0x95, 0x03, 0xbf, 0x4b, 0x19, 0xe6,
        0x18, 0x2e, 0x82, 0x04, 0x95, 0x3e, 0x74, 0x53,
        0xae,
    };
    const ucoin_buf_t wit = { (uint8_t *)REDEEM, sizeof(REDEEM) };

    char waddr[UCOIN_SZ_WSHADDR];
    bool ret = ucoin_keys_wit2waddr(waddr, &wit);
    ASSERT_TRUE(ret);
    ASSERT_EQ('T', waddr[0]);
    ASSERT_EQ('7', waddr[1]);
    ASSERT_EQ('n', waddr[2]);
    ASSERT_EQ(UCOIN_SZ_WSHADDR - 1, strlen(waddr)); //サイズは固定

    //T7nYFLD7YbzuLGr3Euk7X4gVXqUv9Jhvw4cca3zyQ33LtEQFwSDTm
}
